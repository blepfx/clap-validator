//! Abstractions for single CLAP plugin instances for main thread interactions.

mod audio_thread;
mod main_thread;
mod shared;

pub use audio_thread::*;
pub use main_thread::*;
pub use shared::*;

/// An event generated by plugin->host callbacks.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[non_exhaustive]
pub enum CallbackEvent {
    /// clap_plugin::request_process()
    RequestProcess,

    /// clap_plugin_params::request_flush()
    RequestFlush,

    ParamsRescanValues,
    ParamsRescanText,
    ParamsRescanInfo,
    ParamsRescanAll,

    AudioPortsRescanNames,
    AudioPortsRescanAll,
    NotePortsRescanNames,
    NotePortsRescanAll,

    /// clap_plugin_latency::changed()
    LatencyChanged,

    /// clap_plugin_tail::changed()
    TailChanged,

    /// clap_plugin_voice_info::changed()
    VoiceInfoChanged,

    /// clap_plugin_state::mark_dirty()
    StateMarkDirty,
}

/// The plugin's current lifecycle state. This is checked extensively to ensure that the plugin is
/// in the correct state, and things like double activations can't happen. `Plugin` and
/// `PluginAudioThread` will drop down to the previous state automatically when the object is
/// dropped and the stop processing or deactivate functions have not yet been calle.d
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum PluginStatus {
    #[default]
    Uninitialized,
    Deactivated,
    Activating,
    Activated,
    Processing,
}

impl PluginStatus {
    #[track_caller]
    pub fn assert_is(&self, expected: PluginStatus) {
        if *self != expected {
            panic!(
                "Invalid plugin function call while the plugin is in an incorrect state ({:?}, must be {:?})",
                self, expected
            )
        }
    }

    #[track_caller]
    pub fn assert_is_not(&self, unexpected: PluginStatus) {
        if *self == unexpected {
            panic!(
                "Invalid plugin function call while the plugin is in an incorrect state ({:?}, must not be {:?})",
                self, unexpected
            )
        }
    }

    #[track_caller]
    pub fn assert_active(&self) {
        if *self < PluginStatus::Activated {
            panic!(
                "Invalid plugin function call while the plugin is in an incorrect state ({:?}, must be activated)",
                self
            )
        }
    }

    #[track_caller]
    pub fn assert_inactive(&self) {
        if *self >= PluginStatus::Activated {
            panic!(
                "Invalid plugin function call while the plugin is in an incorrect state ({:?}, must be deactivated)",
                self
            )
        }
    }
}
